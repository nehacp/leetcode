/*

Truth Tables
      AND
|-----|-----|-----|
|  A  |  B  | A&B |
|-----|-----|-----|
|  0  |  0  |  0  |
|  1  |  1  |  1  |
|  1  |  0  |  0  |
|  0  |  1  |  0  |
-----------------

      OR
|-----|-----|-----|
|  A  |  B  | A|B |
|-----|-----|-----|
|  0  |  0  |  0  |
|  1  |  1  |  1  |
|  1  |  0  |  1  |
|  0  |  1  |  1  |
-----------------


      NOT
|-----|-----|
|  A  | ~A  |
|-----|-----|
|  0  |  1  |
|  1  |  0  |
-------------


      XOR
|-----|-----|-----|
|  A  |  B  | A^B |
|-----|-----|-----|
|  0  |  0  |  0  |
|  1  |  1  |  0  |
|  1  |  0  |  1  |
|  0  |  1  |  1  |
-----------------

FACTS

x ^ 0s = x
x ^ 1s = ~x
x ^ x = 0

x & 0s = 0
x & 1 = x
x & x = x

x | 0s = x
x | 1s = 1s
x | x = x

NEGATIVE VALUES

-3 complement with respect to 4 bits is 5 is 4 bits that is 2 ^3 = 8. The complement is 8 - 3 = 5;
So represent -3 by respresenting 5 in binary and add 1 before it which is a signed value

if -3 is k, the answer is concat(1, 2 ^ (bitsize - 1) - k);

Another way is to invert the bits, add 1 and then append 1 to the left
e. g. 3 (011) => (100) + 1 = (101) => append 1 to left  = (1101) (-8 + 4 + 0 + 1);

Overflow

In computer processors, the overflow flag (sometime called V flag) is usually a single bit in a system status 
register used to indicate when an arithmetic overflow has occurred in an operation, indicating that the signed 
two's-complement result would not fit in the number of bits used for the operation (the ALU width). Some architectures 
may be configured to automatically generate an exception on an operation resulting in overflow.


An illustrative example is what happens if we add 127 and 127 using 8-bit registers. 127+127 is 254, but
 using 8-bit arithmetic the result would be 1111 1110 binary, which is -2 in two's complement, and thus negative. 
 A negative result out of positive operands (or vice versa) is an overflow. The overflow flag would then be set 
 so the program can be aware of the problem and mitigate this or signal an error. The overflow flag is thus 
 set when the most significant bit (here considered the sign bit) is changed by adding two numbers with the 
 same sign (or subtracting two numbers with opposite signs). Overflow never occurs when the sign of two addition
  operands are different (or the sign of two subtraction operands are the same).

Internally, the overflow flag is usually generated by an exclusive or of the internal carry into and out of the 
sign bit. As the sign bit is the same as the most significant bit of a number considered unsigned, the overflow 
flag is "meaningless" and normally ignored when unsigned numbers are added or subtracted.

*/

const repeatedArithmeticShift = (x, count) => {
  for (let i = 0; i < count; i++) {
    console.log('arithemetic', x, x.toString(2));
    x >>= 1;
  }
  return x;
};

const repeatedLogicalShift = (x, count) => {
  for (let i = 0; i < count; i++) {
    console.log('logical', x, x.toString(2));
    x >>>= 1;
  }
  return x;
};

console.log(repeatedArithmeticShift(-93242, 40));
console.log(repeatedLogicalShift(-93242, 40));
console.log('reconvert', parseInt(10110110000111010, 2));

const getBit = (num, i) => {
  return (num & (1 << i) !== 0);
}

const setBit = (num, i) => {
  return (num | (1 << i);
}